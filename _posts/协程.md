# 协程

## 一、协程的基本概念

### 1.1 什么是协程

协程（Coroutines）是一种比线程更加轻量级的存在，又称为用户级线程。协程完全由程序所控制（在用户态执行），可以自主选择什么时候挂起协程，什么时候重新执行协程。当协程挂起时，会暂存协程的状态，重新运行后会在挂起点继续运行。

### 1.2 协程和线程的区别

协程比线程更加轻量级，是由用户实现并控制的，而线程和进程由操作系统进行创建和控制。

#### 1.2.1 资源拥有

协程仅拥有自己的上下文和协程栈。由于协程是由用户实现的，而不同实现方式可能略微不同，但是拥有的资源大致可以分为上下文和协程栈。其中协程栈多种实现方式，见本节的1.5小节。

而同一个进程内的所有线程共享进程的地址空间、资源，所以线程不被视为资源的分配对象，仅拥有一点归属于自己的资源：

* 独立的线程栈，一般是8MB。
* 寄存器，每个线程都有自己的 CPU 寄存器，用于保存线程的状态和执行上下文。
* 线程描述符，又称为线程控制块，如内核中线程同样使用task_struct作为描述符

而进程拥有的资源就多了：进程栈、页表、文件描述符表、寄存器、进程描述符、信号处理器、环境变量等，

#### 1.2.2 进程/线程/协程切换

协程切换是由应用程序自己控制的，不需要操作系统内核介入，也就是说，协程是在用户态完成切换。

而线程和进程的切换需要内核参与，大致可以分为：

* 保存当前上下文
* 选择下一个调度目标
* 切换到下一个调度目标

线程的切换仅要考虑上下文的保存和执行（因为它只有这些东西），而进程拥有的资源较多，所以它要考虑更多东西，比如页表的切换、信号的检测与执行、cache的刷新等，所以进程的切换可能向下面这个样子：

1. 保存和恢复进程的上下文：进程切换时需要保存当前进程的上下文，包括 CPU 寄存器、程序计数器、用户栈指针、内存映射信息、文件描述符等信息，以便在以后恢复进程的执行状态。同时，需要从下一个进程的进程描述符中恢复进程的上下文。
2. 切换进程的地址空间：进程之间拥有独立的地址空间，进程切换时需要切换地址空间，以便让进程可以访问自己的内存空间。这个过程需要进行大量的页表切换、内存拷贝等操作。
3. 切换内存映射和文件描述符：进程切换时需要切换内存映射和文件描述符，以便让进程可以继续访问自己的文件和共享内存等资源。这个过程需要进行大量的复制和更新操作。
4. 切换 CPU 的控制权：进程切换时需要将 CPU 的控制权切换到下一个进程，让它开始执行。这个过程涉及到 CPU 寄存器、中断控制器等硬件资源的改变。
5. 信号处理：每次进程调度时会通过**TIF_SIGPENDING**标志检测信号位图和pendding队列，是否有信号需要被处理。
6. 更新进程的状态信息：进程切换时需要更新进程的状态信息，包括进程的调度状态、运行时间、优先级等信息。这个过程需要对进程管理数据结构进行修改和更新。
7. cache刷新：cache是用于CPU与内存之间的缓存，当新进程的上下文加载到CPU上之后，cache可能会进行刷新，这个依赖于具体的cache类别、cache hash、架构实现。

### 1.3 协程的分类

协程可以按照栈的有无分为有栈协程，如goroutine，libco；或无栈协程，如C++的协程。

注意，这里的“有栈”并不是指协程运行的时候是否存在栈，而是指协程之间是否存在调用栈。我们知道一个进程在被加载时，系统会自动为它加载程序文件并分配堆栈空间，其中栈空间默认为8MB大小，进程的所有函数调用都依赖于栈，每个函数在栈中都拥有一个栈帧，用来保存当前函数的RBP、RSP寄存器、局部变量等（返回地址和参数保存在上一层函数的栈帧中）：

【这里有图】

有栈协程间存在调用关系，上一层协程调用下一层协程执行，如非对称协程，总是主协程去调用协程。

而无栈协程更像是一种状态机，可以从协程的切换是指令寄存器的改变去理解这一点。如下面这段代码：

```c++
struct test_coroutine {
    int i;
    int __state = 0;
    void MoveNext() {
        switch(__state) {
        case 0:
            return frist();
        case 1:
            return second();
        case 2:
        	return third();
        }
    }
    void frist() {
        i = 0;
        __state = 1;
    }
    void second() {
        i++;
        _state = 2;
    }
    void third() {
    	i--;
    }
};
```

可以将几个协程当作一个类的不同函数，协程间的切换通过状态进行指定，这样更类似函数调用。而所有的协程共享系统栈，因为是函数调用，我们也不用去保存协程上下文，而有栈协程还需为每个协程开辟一个新的空间来放置栈。

除此之外，协程还可以按照协程之间的关系分为对称协程和非对称协程。

在这之前，我们需要了解协程编程中两个基本概念：

* `resume`函数用于启动或恢复一个挂起的协程，将其从挂起状态切换到运行状态。
* `yield`函数用于将当前正在执行的协程挂起，切换到其他协程中执行。

简单理解来说就是，运行一个协程，先resume它，等它执行完之后，再yield回来。

非对称协程与对称协程的区别主要在协程切换方式上：

* 对称协程允许在某个协程中yield到另一个协程中，并保存自己的状态以便下次控制权回转时继续运行
* 非对称协程通常有一个“主协程”的存在，被调度协程只能yield到“主协程”，并且通常不同resume到其他其他协程，只有“主协程”能主动resume到其他被调度协程。

可以简单理解对称协程就像操作系统中的进程调度，有专门的调度器、协程上下文保存协程相关执行信息、调度算法，每个协程之间的关系是对等的，可以自由resume或yield到另一个协程。而非对称协程通常分为“主协程”与被调度协程，resume只能由”主协程“发起，被调度协程只能yield，协程间的关系是不对等的。但是非对称协程实现起来就比较简单了，只需要维护两个协程的上下文就够了：”主协程“上下文、被调度协程上下文。

### 1.4 协程的历史

有历史，但我不考古。

### 1.5 协程栈

协程既可以共享系统栈，如无栈协程，也可以为每个协程开辟一个新的内存空间作为栈，如libco。而协程栈的开辟，也需要考虑许多问题，最直接的一个问题就是栈溢出，连系统栈都可能会溢出，不合理的协程更容易会发生这种情况。所以协程栈的设计是一个比较重要的问题。

#### 1.5.1 静态栈

静态栈是指固定大小的栈，在协程刚开始创建的时候，就会向系统申请固定大小的内存空间作为栈。而静态栈的大小，也是值得商榷的。

对于高并发来说，可能会同时存在数量非常庞大的协程，如何采用与线程相同的默认方案（8MB），那么 1024个协程就要8GB，而每个协程真正使用的栈内存可以几百KB甚至几KB，内存使用率极低，这显然是不可接受的。将协程栈大小限制在128KB是一个比较合理的方案，如libco。但是过小的协程栈会导致协程的使用变得束手束脚，要精打细算每一分内存。

但是如果将问题限定在一个固定范围，并严格控制每一行代码，确保其全部谨慎的使用内存，那么还是可以使用的。

#### 1.5.2 分段栈

> gcc提供的“黄金链接器”支持一种允许栈内存不连续的编译参数，实现原理是在每个函数调用开头都插入一段栈内存检测的代码，如果栈内存不够用了就申请一块新的内存，作为栈内存的延续。
>
> 这种方案本应是最佳的实现，但如果遇到的第三方库没有使用这种方式来编译(注意:glibc也是这里提到的”第三方库")，那就无法在其中检测栈内存是否需要扩展，栈溢出的风险很大。[[1]](#ref1)

#### 1.5.3 拷贝栈

> 每次检测到栈内存不够用时，申请一块更大的新内存，将现有的栈内存copy过去，就像std::vector那样扩展内存。
>
> 在某些语言上是可以实现这样的机制，但C++ 是有指针的，栈内存的Copy会导致指向其内存地址的指针失效；又因为其指针的灵活性(可以加减运算)，修改对应的指针成为了一种几乎不可能实现的事情(参照c++ 为什么没办法实现gc原理,详见《C++11新特性解析与应用》第5章 5.2.4节)。[[1]](#ref1)

#### 1.5.4 共享栈

申请一块大内存作为共享栈(比如：8MB)，每次开始运行协程之前，先把协程栈的内存copy到共享栈中，运行结束后再计算协程栈真正使用的内存，copy出来保存起来，这样每次只需保存真正使用到的栈内存量即可。这种方案极大程度上避免了内存的浪费，做到了用多少占多少，同等内存条件下，可以启动的协程数量更多，libco使用这种方案单机启动了上千万协程。

但是这种方案的缺陷也同样明显：

1. 协程切换慢：每次协程切换，都需要2次Copy协程栈内存，这个内存量基本上都在1KB以上，通常是几十KB甚至几百KB，这样的2次Copy要花费很长的时间
2. 栈上引用失效。用于使用了栈拷贝，那么可能会导致在协程中的引用失效。

#### 1.5.5 虚拟内存栈

虚拟内存栈利用了虚拟内存的特点：只要不使用，就不会占用实际的物理内存空间。所以可以为协程申请一个较大的虚拟内存空间，当实际上需要使用时，再触发Page Fault去获取物理内存，用多少申请多少，实现了与共享内存栈类似的内存使用率，且不存在共享栈的两个弊端。

如Libgo就使用了这种方式。

### 1.7 hook

> 是否有HOOK是一个协程库定位到玩具级和工业级之间的重要分水岭； HOOK的底层实现是否遵从HOOK的基本守则；决定着用户是如履薄冰的使用一个漏洞百出的协程库？还是可以挥洒自如的使用一个稳定健壮的协程库？[[1]](#ref1)

**hook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。**hook和IO协程调度是密切相关的，如果不使用IO协程调度器，那hook没有任何意义，考虑IOManager要在一个线程上按顺序调度以下协程：

1. 协程1：`sleep(2)` 睡眠两秒后返回。
2. 协程2：在scoket fd 1 上`send` 100k数据。
3. 协程3：在socket fd2 上`recv`直到数据接收成功。

在未hook的情况下，IOManager要调度上面的协程，流程是下面这样的：

1. 调度协程1，协程阻塞在`sleep`上，等2秒后返回，这两秒内调度线程是被协程1占用的，其他协程无法在当前线程上调度。
2. 调度协徎2，协程阻塞`send` 100k数据上，这个操作一般问题不大，因为send数据无论如何都要占用时间，但如果fd迟迟不可写，那send会阻塞直到套接字可写，同样，在阻塞期间，其他协程也无法在当前线程上调度。
3. 调度协程3，协程阻塞在`recv`上，这个操作要直到`recv`超时或是有数据时才返回，期间调度器也无法调度其他协程。

上面的调度流程最终总结起来就是，协程只能按顺序调度，一旦有一个协程阻塞住了，那整个调度线程也就阻塞住了，其他的协程都无法在当前线程上执行。像这种一条路走到黑的方式其实并不是完全不可避免，以sleep为例，调度器完全可以在检测到协程sleep后，将协程yield以让出执行权，同时设置一个定时器，2秒后再将协程重新resume。这样，调度器就可以在这2秒期间调度其他的任务，同时还可以顺利的实现sleep 2秒后再继续执行协程的效果，send/recv与此类似。在完全实现hook后，IOManager的执行流程将变成下面的方式：

1. 调度协程1，检测到协程`sleep`，那么先添加一个2秒的定时器，定时器回调函数是在调度器上继续调度本协程，接着协程`yield`，等定时器超时。
2. 因为上一步协程1已经`yield`了，所以协徎2并不需要等2秒后才可以执行，而是立刻可以执行。同样，调度器检测到协程`send`，由于不知道fd是不是马上可写，所以先在IOManager上给fd注册一个写事件，回调函数是让当前协程`resume`并执行实际的`send`操作，然后当前协程`yield`，等可写事件发生。
3. 上一步协徎2也`yield`了，可以马上调度协程3。协程3与协程2类似，也是给fd注册一个读事件，回调函数是让当前协程`resume`并继续recv，然后本协程yield，等事件发生。
4. 等2秒超时后，执行定时器回调函数，将协程1 `resume`以便继续执行。
5. 等协程2的fd可写，一旦可写，调用写事件回调函数将协程2 `resume`以便继续执行`send`。
6. 等协程3的fd可读，一旦可读，调用回调函数将协程3 `resume`以便继续执行`recv`。

上面的4、5、6步都是异步的，调度线程并不会阻塞，IOManager仍然可以调度其他的任务，只在相关的事件发生后，再继续执行对应的任务即可。并且，由于hook的函数签名与原函数一样，所以对调用方也很方便，只需要以同步的方式编写代码，实现的效果却是异步执行的，效率很高。

除此之外，在hook之前，我们就主动将阻塞文件描述符设置为了非阻塞的文件描述符，但是在使用者看来，这个文件描述符是阻塞的，也即是在hook的过程中我们要维护文件描述符的“阻塞一致性”。比如对于fcntl、ioctl、dup等函数来说，我们也需要完成对它们的hook，使得通过这些函数返回的文件属性/操作，是阻塞文件。

### 1.8 channel

和线程一样，协程间也是需要交换数据。协程之间也可以存在数据同步关系、通信关系，最典型的如golang中的`channel`。

### 1.9 协程锁

对于协程库来说，使用线程锁很可能会导致死锁的问题。

比如当线程A调用了协程A，协程A中申请了一个线程锁，然后陷入睡眠，此时会因为hook模块而切换到另一个协程执行。当另一个协程A被线程A调用时，由于在上一个协程A中已经申请了线程锁还没有释放（因为sleep被hook了），这时另一个协程A就会因为得不到锁而阻塞，从而线程A就没办法进行协程切换，死锁就这样诞生了。

对于以上状况来说，实现协程锁是一种有效的避免手段。

如果实现了协程锁，那么对于以上情况，当另一个协程A申请锁时，会因为得不到协程锁而将自身挂起，等待锁被释放。而协程A在睡眠时间结束后会继续自己的逻辑，然后释放锁，另一个协程A也因此被唤醒，从而避免了死锁的发生。

### 1.10 异步回调模式和协程模式

> 为了避免频繁的上下文切换，还有一种异步非阻塞的开发模型。那就是用一个进程或线程去接收一大堆用户的请求，然后通过IO多路复用的方式来提高性能（进程或线程不阻塞，省去了上下文切换的开销）。Nginx和Node Js就是这种模型的典型代表产品。平心而论，从程序运行效率上来，这种模型最为机器友好，运行效率是最高的（比下面提到的协程开发模型要好）。所以Nginx已经取代了Apache成为了Web Server里的首选。但是这种编程模型的问题在于开发不友好，说白了就是过于机器化，离进程概念被抽象出来的初衷背道而驰。人类正常的线性思维被打乱，应用层开发们被逼得以非人类的思维去编写代码，代码调试也变得异常困难。
>
> 于是就有一些聪明的脑袋们继续在应用层又动起了主意，设计出了不需要进程/线程上下文切换的“线程”，协程。用协程去处理高并发的应用场景，既能够符合进程涉及的初衷，让开发者们用人类正常的线性的思维去处理自己的业务，也同样能够省去昂贵的进程/线程上下文切换的开销。因此可以说，协程就是Linux处理海量请求应用场景里的进程模型的一个很好的的补丁。[[3]](#ref3)

Callback Hell（回调地狱）是指在异步编程中，过多的回调函数嵌套所产生的一种代码风格，使得代码难以理解和维护。当一个回调函数中又包含了另一个回调函数，而这个回调函数中又包含了另一个回调函数，以此类推，代码就会变得非常复杂和难以阅读，这就是 Callback Hell。

Callback Hell 的出现是由于 JavaScript 中的异步编程模型，例如事件驱动编程、回调函数、Promise 等。在这些编程模型中，为了避免阻塞主线程，通常会使用回调函数的方式来处理异步任务。但是，如果异步任务的嵌套过于复杂，就会导致代码难以维护和扩展。

### 1.11  一些协程框架

C++11中没有提供对协程的直接支持，但是它提供了几个API可以供开发者来实现一个简单的协程库，这就是大家熟悉的ucontext。而直到C++20才开始显式的支持协程。

第三方库倒是有很多，比如2013年微信团队提出的Libco，第三方库Libgo，而golang语言更是将协程当成语言特性来实现，导致很多goer“只知协程而不知线程”。

著名的boost也提供了协程的支持，如boost.context、boost.coroutine。boost.context的性能、兼容性都是当前最佳的，推荐使用。

接下来我会简单介绍这些协程库的使用。

## 二、ucontext

ucontext是glibc的一个组件，可以被用来实现一个简单的协程库，它的核心由一个数据结构以及四个调用函数组成（少吧？）。

ucontext通过结构体`struct ucontext_t`保存协程上下文：

```c++
typedef struct ucontext {
    struct ucontext *uc_link;		// 当前上下文结束后运行该成员指向的上下文
    sigset_t         uc_sigmask;	// 该上下文的阻塞信号集合
    stack_t          uc_stack;		// 该上下文使用的栈
    mcontext_t       uc_mcontext;	// 保存的上下文，特定于体系结构
    ...
} ucontext_t;
```

 有了保存上下文的结构，想要实现一个简单的协程，那么接下来就需要：

* 保存上下文
* 切换上下文

ucontext提供四个函数来完成上面两个功能：

**getcontext**

```c++
int getcontext(ucontext_t *ucp);
```

 初始化ucp结构体，将当前的上下文保存到ucp中，调用成功返回0，否则返回-1。

注意，协程上下文通常不能自己初始化（比如直接定义一个空的ucontext_t然后直接切换），需要借助`getcontext`来完成初始化工作。

**setcontext**

```c++
int setcontext(const ucontext_t *ucp);
```

设置当前的上下文为ucp，setcontext的上下文ucp应该通过getcontext或者makecontext取得，如果成功，则该函数不会返回，如果出现错误，则返回-1。

* 如果上下文是通过调用getcontext()取得，程序会继续执行这个调用。
* 如果上下文是通过调用makecontext取得，程序会调用makecontext函数的第二个参数指向的函数，如果func函数返回，则恢复makecontext第一个参数指向的上下文context_t中指向的uc_link。如果uc_link为NULL,则线程退出。

**makecontext**

```c++
void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);
```

makecontext用于修改协程上下文的栈空间uc_stack、后继指针uc_link，func为函数指针，argc为函数指针的参数，后面跟具体的参数。

如果上下文通过`setcontext`或`swapcontext`激活后，会主动执行func函数，uc_mcontext保存当前函数执行的状态（上下文），当func执行完毕后，会继续执行后继上下文uc_link（不为NULL的话）。

**swapcontext**

```c++
int swapcontext(ucontext_t *oucp, ucontext_t *ucp);
```

**保存当前上下文到oucp结构体中，然后激活upc上下文。** 如果成功，则该函数不会返回；如果出现错误，则返回-1，并设置错误码errno。注意，该函数会保存当前上下文到oucp中！

简单来说，通过ucontext实现的协程库基本上就是：

* getcontext获取当前上下文，初始化一个基本的协程结构
* makecontext传递函数指针、函数参数、栈空间给要运行的协程上下文
* swapcontext保存当前协程上下文，并切换到要运行的协程上下文
* setcontext没怎么用过。

## 三、Libco

### 3.1 Libco的简单介绍

libco是一个基于协程的轻量级网络库，由腾讯开发，支持跨平台，可以用于实现高并发的网络服务器和客户端。它的底层实现基于共享栈技术，可以实现高效的协程管理和调度。

libco的协程库支持两种不同类型的协程：对称协程（symmetric coroutine）和半对称协程（asymmetric coroutine）。对称协程是一种可以在协程之间相互切换执行的协程，它们共享同一个栈空间和状态，可以方便地实现协程调度和状态机。半对称协程则是一种主协程/子协程的模式，主协程可以控制子协程的执行流程和状态，并且可以在不同的线程中执行。

> 而 libco 提供的协程，虽然编程接口跟 pthread 有点类似，“类 pthread 的接口设计”、“如线程库一样轻松”，本质上却是一种非对称协程。这一点不要被表象蒙蔽了。[[6]](#ref6)

libco的协程库使用共享栈技术来管理协程的栈空间，支持动态分配和释放栈空间，可以节省内存开销。同时，它还提供了高效的协程切换和调度机制，可以实现高并发的网络编程。

除了协程库，libco还提供了一些网络编程相关的工具和函数，例如coroutine_socket、coroutine_poll等，可以方便地实现网络编程。同时，它还支持多种协议和编解码格式，例如TCP、UDP、HTTP、WebSocket等。

libco的协程切换是通过汇编来实现的，这一点ucontext也一样。

libco的HOOK不能支持真正的全静态链接

## 四、Libgo

显而易见，调用void set_et_mode(int fd);接口将频繁读写的socket设置成et模式可以减少epoll相关的系统调用，提升性能；

## 五、Go

## 六、C++20



## 七、boost.context

## 八、参考引用

1. <span id="ref1">[C++ 协程的近况、设计与实现中的细节和决策](https://www.jianshu.com/p/837bb161793a)</span>
2. <span id="ref2">[同步与异步，回调与协程](https://www.cnblogs.com/xybaby/p/6406191.html)</span>
3. <span id="ref3">[协程究竟比线程牛在什么地方？](https://cloud.tencent.com/developer/article/1963146)</span>
4. <span id="ref4">[协程到底有什么用？六种I/O模式告诉你！](https://www.51cto.com/article/709154.html)</span>
5. <span id="ref5">[浅谈有栈协程与无栈协程](https://zhuanlan.zhihu.com/p/347445164)</span>
6. <span id="ref6">[微信开源C++Libco介绍与应用（一）](https://zhuanlan.zhihu.com/p/51078499)</span>
7. [CppCon 2018: G. Nishanov “Nano-coroutines to the Rescue! (Using Coroutines TS, of Course)”](https://www.youtube.com/watch?v=j9tlJAqMV7U)



